laoluo-1 | Android学习启动篇 | http://blog.csdn.net/luoshengyang/article/details/6557518 | description:近年来，手机移动平台越来越火爆。打开自己的QQ算了一下，在线好友共有31个，其中用手机上的有13个，手机用户占了42%；打开新浪微博、天涯和猫扑等网站，各种终端设备的发贴、回贴更是数不胜数。目前，手机平台如日中天的要数是iOS和Android了，尤其是iOS，Symbian已没落，WP7在挣扎。iOS一如既往地走Apple特色的封闭道路，然而它的强大在于能够建立一个完整的生态系统，乔布斯确实是天之... 2011-06-21 00:32 (123335) (96)
laoluo-2 | 在Ubuntu上下载、编译和安装Android最新源代码 | http://blog.csdn.net/luoshengyang/article/details/6559955 | description:看完了前面说的几本书之后，对Linux Kernel和Android有一定的认识了，是不是心里蠢蠢欲动，想小试牛刀自己编译一把Android源代码了呢？一直习惯使用Windows系统，而Android源代码是不支持在Windows上编译上，于是决定使用虚拟机安装Ubuntu，然后下载、编译和安装Android源代码。     一. 环境准备。     1. 磁盘空间预留20G左右，内存3G，因为一... 2011-06-21 23:15 (208502) (290)
laoluo-3 | 在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel） | http://blog.csdn.net/luoshengyang/article/details/6564592 | description:在前一篇文章提到，从源代码树下载下来的最新Android源代码，是不包括内核代码的，也就是Android源代码工程默认不包含Linux Kernel代码，而是使用预先编译好的内核，也就是prebuilt/android-arm/kernel/kernel-qemu文件。那么，如何才能DIY自己的内核呢？这篇文章一一道来。      一. 首选，参照前一篇在Ubuntu上下载、编译和安装Androi... 2011-06-23 22:53 (117769) (140)
laoluo-4 | 如何单独编译Android源代码中的模块 | http://blog.csdn.net/luoshengyang/article/details/6566662 | description:第一次下载好Android源代码工程后，我们通常是在Android源代码工程目录下执行make命令，经过漫长的等待之后，就可以得到Android系统镜像system.img了。以后如果我们修改了Android源代码中的某个模块或者在Android源代码工程新增一个自己的模块，是不是还是执行make命令呢？答案是否定的，Google为我们准备了另外的命令来支持编译单独的模块，以及重新打包system... 2011-06-24 22:07 (121361) (108)
laoluo-5 | Android硬件抽象层（HAL）概要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6567257 | description:Android的硬件抽象层，简单来说，就是对Linux内核驱动程序的封装，向上提供接口，屏蔽低层的实现细节。也就是说，把对硬件的支持分成了两层，一层放在用户空间（User Space），一层放在内核空间（Kernel Space），其中，硬件抽象层运行在用户空间，而Linux内核驱动程序运行在内核空间。为什么要这样安排呢？把硬件抽象层和内核驱动整合在一起放在内核空间不可行吗？从技术实现的角度来看，... 2011-06-25 13:03 (146212) (47)
laoluo-6 | 在Ubuntu上为Android系统编写Linux内核驱动程序 | http://blog.csdn.net/luoshengyang/article/details/6568411 | parentid:laoluo-5 description:在智能手机时代，每个品牌的手机都有自己的个性特点。正是依靠这种与众不同的个性来吸引用户，营造品牌凝聚力和用户忠城度，典型的代表非iphone莫属了。据统计，截止2011年5月，AppStore的应用软件数量达381062个，位居第一，而Android Market的应用软件数量达294738，紧随AppStore后面，并有望在8月份越过AppStore。随着Android系统逐步扩大市场占有率，终... 2011-06-26 12:10 (138805) (188)
laoluo-7 | 在Ubuntu上为Android系统内置C可执行程序测试Linux内核驱动程序 | http://blog.csdn.net/luoshengyang/article/details/6571210 | parentid:laoluo-5 description:在前一篇文章中，我们介绍了如何在Ubuntu上为Android系统编写Linux内核驱动程序。在这个名为hello的Linux内核驱动程序中，创建三个不同的文件节点来供用户空间访问，分别是传统的设备文件/dev/hello、proc系统文件/proc/hello和devfs系统属性文件/sys/class/hello/hello/val。进一步，还通过cat命令来直接访问/proc/hello和/... 2011-06-27 22:00 (77121) (101)
laoluo-8 | 在Ubuntu上为Android增加硬件抽象层（HAL）模块访问Linux内核驱动程序 | http://blog.csdn.net/luoshengyang/article/details/6573809 | parentid:laoluo-5 description:在Android硬件抽象层（HAL）概要介绍和学习计划一文中，我们简要介绍了在Android系统为为硬件编写驱动程序的方法。简单来说，硬件驱动程序一方面分布在Linux内核中，另一方面分布在用户空间的硬件抽象层中。接着，在Ubuntu上为Android系统编写Linux内核驱动程序一文中举例子说明了如何在Linux内核编写驱动程序。在这一篇文章中，我们将继续介绍Android系统硬件驱动程序的另一... 2011-06-28 22:52 (92952) (136)
laoluo-9 | 在Ubuntu为Android硬件抽象层（HAL）模块编写JNI方法提供Java访问硬件服务接口 | http://blog.csdn.net/luoshengyang/article/details/6575988 | parentid:laoluo-5 description:在上两篇文章中，我们介绍了如何为Android系统的硬件编写驱动程序，包括如何在Linux内核空间实现内核驱动程序和在用户空间实现硬件抽象层接口。实现这两者的目的是为了向更上一层提供硬件访问接口，即为Android的Application Frameworks层提供硬件服务。我们知道，Android系统的应用程序是用Java语言编写的，而硬件驱动程序是用C语言来实现的，那么，Java接口如何去访问... 2011-06-29 22:27 (95022) (107)
laoluo-10 | 在Ubuntu上为Android系统的Application Frameworks层增加硬件访问服务 | http://blog.csdn.net/luoshengyang/article/details/6578352 | parentid:laoluo-5 description:在数字科技日新月异的今天，软件和硬件的完美结合，造就了智能移动设备的流行。今天大家对iOS和Android系统的趋之若鹜，一定程度上是由于这两个系统上有着丰富多彩的各种应用软件。因此，软件和硬件的关系，在一定程度上可以说，硬件是为软件服务的。硬件工程师研发出一款硬件设备，自然少了软件工程师为其编写驱动程序；而驱动程序的最终目的，是为了使得最上层的应用程序能够使用这些硬件提供的服务来为用户提供软件功... 2011-06-30 23:10 (72153) (86)
laoluo-11 | 在Ubuntu上为Android系统内置Java应用程序测试Application Frameworks层的硬件服务 | http://blog.csdn.net/luoshengyang/article/details/6580267 | parentid:laoluo-5 description:我们在Android系统增加硬件服务的目的是为了让应用层的APP能够通过Java接口来访问硬件服务。那么， APP如何通过Java接口来访问Application Frameworks层提供的硬件服务呢？在这一篇文章中，我们将在Android系统的应用层增加一个内置的应用程序，这个内置的应用程序通过ServiceManager接口获取指定的服务，然后通过这个服务来获得硬件服务。        一.... 2011-07-02 14:35 (67995) (185)
laoluo-12 | 浅谈Android系统开发中LOG的使用 | http://blog.csdn.net/luoshengyang/article/details/6581828 | parentid:laoluo-5 description:在程序开发过程中，LOG是广泛使用的用来记录程序执行过程的机制，它既可以用于程序调试，也可以用于产品运营中的事件记录。在Android系统中，提供了简单、便利的LOG机制，开发人员可以方便地使用。在这一篇文章中，我们简单介绍在Android内核空间和用户空间中LOG的使用和查看方法。        一. 内核开发时LOG的使用。Android内核是基于Linux Kerne 2.36的，因此，Li... 2011-07-03 16:47 (92804) (23)
laoluo-13 | 制作可独立分发的Android模拟器 | http://blog.csdn.net/luoshengyang/article/details/6586759 | parentid:laoluo-5 description:如果我们编写了一个Android应用程序，想在一台没有Android SDK或者BUILD环境的机器显示给别人看，应该怎么办呢？通常，我们开发Android应用程序的时候，都是使用模拟器来运行程序，要么是SDK环境下，要么是在源代码BUILD环境下使用。在SDK环境下，结合Eclipse和ADT，使用模拟器很方便，而BUILD环境下，也是很简单地使用emulator命令就可以了，具体可以参考在Ub... 2011-07-05 22:57 (41051) (30)
laoluo-14 | 介绍一款Android小游戏--交互式人机对战五子棋 | http://blog.csdn.net/luoshengyang/article/details/6589025 | parentid:laoluo-5 description:学习Android系统开发之余，编写了一个小游戏--交互式人机对战五子棋，自娱自乐。之所以称之为交互式人机对战五子棋，一是因为在进入人机对战模式这前，你可以任意设置好开局，同时，在对战过程中，你可以看到机器的思考过程，还可以标识出每一个落子点的优劣势；二是因为可以为机器增加游戏经验，使得机器越来越聪明。希望喜欢五子棋的同学能够喜欢，同时，它也非常适合入门级练习。       首先展示一下这款五子棋... 2011-07-06 23:51 (36826) (26)
laoluo-15 | Android日志系统驱动程序Logger源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6595744 | parentid:laoluo-5 description:我们知道，在Android系统中，提供了一个轻量级的日志系统，这个日志系统是以驱动程序的形式实现在内核空间的，而在用户空间分别提供了Java接口和C/C++接口来使用这个日志系统，取决于你编写的是Android应用程序还是系统组件。在前面的文章浅谈Android系统开发中LOG的使用中，已经简要地介绍了在Android应用程序开发中Log的使用方法，在这一篇文章中，我们将更进一步地分析Logger... 2011-07-10 13:50 (49646) (25)
laoluo-16 | Android应用程序框架层和系统运行库层日志系统源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6598703 | parentid:laoluo-5 description:在开发Android应用程序时，少不了使用Log来监控和调试程序的执行。在上一篇文章Android日志系统驱动程序Logger源代码分析中，我们分析了驱动程序Logger的源代码，在前面的文章浅谈Android系统开发中Log的使用一文，我们也简单介绍在应用程序中使Log的方法，在这篇文章中，我们将详细介绍Android应用程序框架层和系统运行库存层日志系统的源代码，使得我们可以更好地理解Andr... 2011-07-11 23:26 (36063) (11)
laoluo-17 | Android日志系统Logcat源代码简要分析 | http://blog.csdn.net/luoshengyang/article/details/6606957 | parentid:laoluo-5 description:在前面两篇文章Android日志系统驱动程序Logger源代码分析和Android应用程序框架层和系统运行库层日志系统源代码中，介绍了Android内核空间层、系统运行库层和应用程序框架层日志系统相关的源代码，其中，后一篇文章着重介绍了日志的写入操作。为了描述完整性，这篇文章着重介绍日志的读取操作，这就是我们在开发Android应用程序时，经常要用到日志查看工具Logcat了。        Lo... 2011-07-15 02:27 (57129) (10)
laoluo-18 | Android进程间通信（IPC）机制Binder简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6618363 | description:在Android系统中，每一个应用程序都是由一些Activity和Service组成的，这些Activity和Service有可能运行在同一个进程中，也有可能运行在不同的进程中。那么，不在同一个进程的Activity或者Service是如何通信的呢？这就是本文中要介绍的Binder进程间通信机制了。... 2011-07-20 02:36 (245243) (99)
laoluo-19 | 浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路 | http://blog.csdn.net/luoshengyang/article/details/6621566 | parentid:laoluo-18 description:上一篇文章Android进程间通信（IPC）机制Binder简要介绍和学习计划简要介绍了Android系统进程间通信机制Binder的总体架构，它由Client、Server、Service Manager和驱动程序Binder四个组件构成。本文着重介绍组件Service Manager，它是整个Binder机制的守护进程，用来管理开发者创建的各种Server，并且向Client提供查询Serve... 2011-07-22 02:32 (115804) (93)
laoluo-20 | 浅谈Android系统进程间通信（IPC）机制Binder中的Server和Client获得Service Manager接口之路 | http://blog.csdn.net/luoshengyang/article/details/6627260 | parentid:laoluo-18 description:在前面一篇文章浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路中，介绍了Service Manager是如何成为Binder机制的守护进程的。既然作为守护进程，Service Manager的职责当然就是为Server和Client服务了。那么，Server和Client如何获得Service Manager接口，进而享受它提供的服务呢？本文将简... 2011-07-23 12:16 (70988) (48)
laoluo-21 | Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6629298 | parentid:laoluo-18 description:在前面一篇文章浅谈Android系统进程间通信（IPC）机制Binder中的Server和Client获得Service Manager接口之路中，介绍了在Android系统中Binder进程间通信机制中的Server角色是如何获得Service Manager远程接口的，即defaultServiceManager函数的实现。Server获得了Service Manager远程接口之后，就要把自... 2011-07-25 02:43 (69785) (114)
laoluo-22 | Android系统进程间通信（IPC）机制Binder中的Client获得Server远程接口过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6633311 | parentid:laoluo-18 description:在上一篇文章中，我们分析了Android系统进程间通信机制Binder中的Server在启动过程使用Service Manager的addService接口把自己添加到Service Manager守护过程中接受管理。在这一篇文章中，我们将深入到Binder驱动程序源代码去分析Client是如何通过Service Manager的getService接口中来获得Server远程接口的。Client... 2011-07-27 02:36 (50185) (55)
laoluo-23 | Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6642463 | parentid:laoluo-18 description:在前面几篇文章中，我们详细介绍了Android系统进程间通信机制Binder的原理，并且深入分析了系统提供的Binder运行库和驱动程序的源代码。细心的读者会发现，这几篇文章分析的Binder接口都是基于C/C++语言来实现的，但是我们在编写应用程序都是基于Java语言的，那么，我们如何使用Java语言来使用系统的Binder机制来进行进程间通信呢？这就是本文要介绍的Android系统应用程序框架... 2011-07-30 01:48 (66635) (81)
laoluo-24 | Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6651971 | description:在Android系统中，提供了独特的匿名共享内存子系统Ashmem（Anonymous Shared Memory），它以驱动程序的形式实现在内核空间中。它有两个特点，一是能够辅助内存管理系统来有效地管理不再使用的内存块，二是它通过Binder进程间通信机制来实现进程间的内存共享。本文中，我们将通过实例来简要介绍Android系统的匿名共享内存的使用方法，使得我们对Android系统的匿名共享内存... 2011-08-05 00:11 (58733) (35)
laoluo-25 | Android系统匿名共享内存Ashmem（Anonymous Shared Memory）驱动程序源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6664554 | parentid:laoluo-24 description:在上一文章Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划中，我们简要介绍了Android系统的匿名共享内存机制，其中，简要提到了它具有辅助内存管理系统来有效地管理内存的特点，但是没有进一步去了解它是如何实现的。在本文中，我们将通过分析Android系统的匿名共享内存Ashmem驱动程序的源代码，来深入了解它是如何辅助内存管理系... 2011-08-07 21:28 (40335) (5)
laoluo-26 | Android系统匿名共享内存Ashmem（Anonymous Shared Memory）在进程间共享的原理分析 | http://blog.csdn.net/luoshengyang/article/details/6666491 | parentid:laoluo-24 description:在前面一篇文章Android系统匿名共享内存Ashmem（Anonymous Shared Memory）驱动程序源代码分析中，我们系统地介绍了Android系统匿名共享内存的实现原理，其中着重介绍了它是如何辅助内存管理系统来有效地管理内存的，在再前面一篇文章Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划中，我们还提到，Android... 2011-08-08 00:14 (36406) (8)
laoluo-27 | Android系统在新进程中启动自定义服务过程（startService）的原理分析 | http://blog.csdn.net/luoshengyang/article/details/6677029 | parentid:laoluo-24 description:在编写Android应用程序时，我们一般将一些计算型的逻辑放在一个独立的进程来处理，这样主进程仍然可以流畅地响应界面事件，提高用户体验。Android系统为我们提供了一个Service类，我们可以实现一个以Service为基类的服务子类，在里面实现自己的计算型逻辑，然后在主进程通过startService函数来启动这个服务。在本文中，将详细分析主进程是如何通过startService函数来在新进程... 2011-08-12 01:22 (95625) (107)
laoluo-28 | Android应用程序的Activity启动过程简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6685853 | description:在Android系统中，Activity和Service是应用程序的核心组件，它们以松藕合的方式组合在一起构成了一个完整的应用程序，这得益于应用程序框架层提供了一套完整的机制来协助应用程序启动这些Activity和Service，以及提供Binder机制帮助它们相互间进行通信。在前面的文章Android进程间通信（IPC）机制Binder简要介绍和学习计划和Android系统在新进程中启动自定义服... 2011-08-14 15:46 (84412) (34)
laoluo-29 | Android应用程序启动过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6689748 | parentid:laoluo-28 description:前文简要介绍了Android应用程序的Activity的启动过程。在Android系统中，应用程序是由Activity组成的，因此，应用程序的启动过程实际上就是应用程序中的默认Activity的启动过程，本文将详细分析应用程序框架层的源代码，了解Android应用程序的启动过程。        在上一篇文章Android应用程序的Activity启动过程简要介绍和学习计划中，我们举例子说明了启动A... 2011-08-19 00:58 (193333) (375)
laoluo-30 | Android应用程序内部启动Activity过程（startActivity）的源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6703247 | parentid:laoluo-28 description:上文介绍了Android应用程序的启动过程，即应用程序默认Activity的启动过程，一般来说，这种默认Activity是在新的进程和任务中启动的；本文将继续分析在应用程序内部启动非默认Activity的过程的源代码，这种非默认Activity一般是在原来的进程和任务中启动的。        这里，我们像上一篇文章Android应用程序启动过程源代码分析一样，采用再上一篇文章Android应用程序... 2011-08-22 00:57 (93595) (67)
laoluo-31 | 解开Android应用程序组件Activity的"singleTask"之谜 | http://blog.csdn.net/luoshengyang/article/details/6714543 | parentid:laoluo-28 description:在Android应用程序中，可以配置Activity以四种方式来启动，其中最令人迷惑的就是"singleTask"这种方式了，官方文档称以这种方式启动的Activity总是属于一个任务的根Activity。果真如此吗？本文将为你解开Activity的"singleTask"之谜。        在解开这个谜之前，我们先来简单了解一下在Android应用程序中，任务（Task）是个什么样的概念。我们... 2011-08-25 01:13 (71683) (45)
laoluo-32 | Android应用程序在新的进程中启动新的Activity的方法和过程分析 | http://blog.csdn.net/luoshengyang/article/details/6720261 | parentid:laoluo-28 description:前面我们在分析Activity启动过程的时候，看到同一个应用程序的Activity一般都是在同一个进程中启动，事实上，Activity也可以像Service一样在新的进程中启动，这样，一个应用程序就可以跨越好几个进程了，本文就分析一下在新的进程中启动Activity的方法和过程。        在前面Android进程间通信（IPC）机制Binder简要介绍和学习计划一文中，我们提到，在Andro... 2011-08-29 00:59 (48630) (25)
laoluo-33 | Android系统中的广播（Broadcast）机制简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6730748 | description:在Android系统中，广播（Broadcast）是在组件之间传播数据（Intent）的一种机制；这些组件甚至是可以位于不同的进程中，这样它就像Binder机制一样，起到进程间通信的作用；本文通过一个简单的例子来学习Android系统的广播机制，为后续分析广播机制的源代码作准备。        在Android系统中，为什么需要广播机制呢？广播机制，本质上它就是一种组件间的通信方式，如果是两个组件... 2011-08-31 01:12 (69514) (43)
laoluo-34 | Android应用程序注册广播接收器（registerReceiver）的过程分析 | http://blog.csdn.net/luoshengyang/article/details/6737352 | parentid:laoluo-33 description:前面我们介绍了Android系统的广播机制，从本质来说，它是一种消息订阅/发布机制，因此，使用这种消息驱动模型的第一步便是订阅消息；而对Android应用程序来说，订阅消息其实就是注册广播接收器，本文将探讨Android应用程序是如何注册广播接收器以及把广播接收器注册到哪里去的。        在Android的广播机制中，ActivityManagerService扮演着广播中心的角色，负责系统... 2011-09-02 01:26 (103738) (37)
laoluo-35 | Android应用程序发送广播（sendBroadcast）的过程分析 | http://blog.csdn.net/luoshengyang/article/details/6744448 | parentid:laoluo-33 description:前面我们分析了Android应用程序注册广播接收器的过程，这个过程只完成了万里长征的第一步，接下来它还要等待ActivityManagerService将广播分发过来。ActivityManagerService是如何得到广播并把它分发出去的呢？这就是本文要介绍的广播发送过程了。        广播的发送过程比广播接收器的注册过程要复杂得多了，不过这个过程仍然是以ActivityManagerSe... 2011-09-05 01:01 (100274) (48)
laoluo-36 | Android应用程序绑定服务（bindService）的过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6745181 | parentid:laoluo-33 description:Android应用程序组件Service与Activity一样，既可以在新的进程中启动，也可以在应用程序进程内部启动；前面我们已经分析了在新的进程中启动Service的过程，本文将要介绍在应用程序内部绑定Service的过程，这是一种在应用程序进程内部启动Service的方法。        在前面一篇文章Android进程间通信（IPC）机制Binder简要介绍和学习计划中，我们就曾经提到，在A... 2011-09-07 00:57 (52235) (63)
laoluo-37 | Android应用程序进程启动过程的源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6747696 | parentid:laoluo-33 description:Android应用程序框架层创建的应用程序进程具有两个特点，一是进程的入口函数是ActivityThread.main，二是进程天然支持Binder进程间通信机制；这两个特点都是在进程的初始化过程中实现的，本文将详细分析Android应用程序进程创建过程中是如何实现这两个特点的。        Android应用程序框架层创建的应用程序进程的入口函数是ActivityThread.main比较好理... 2011-09-09 01:01 (70653) (45)
laoluo-38 | Android应用程序安装过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6766010 | parentid:laoluo-33 description:Android系统在启动的过程中，会启动一个应用程序管理服务PackageManagerService，这个服务负责扫描系统中特定的目录，找到里面的应用程序文件，即以Apk为后缀的文件，然后对这些文件进解析，得到应用程序的相关信息，完成应用程序的安装过程，本文将详细分析这个过程。        应用程序管理服务PackageManagerService安装应用程序的过程，其实就是解析析应用程序配置... 2011-09-14 00:59 (76498) (108)
laoluo-39 | Android系统默认Home应用程序（Launcher）的启动过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6767736 | parentid:laoluo-33 description:在前面一篇文章中，我们分析了Android系统在启动时安装应用程序的过程，这些应用程序安装好之后，还需要有一个Home应用程序来负责把它们在桌面上展示出来，在Android系统中，这个默认的Home应用程序就是Launcher了，本文将详细分析Launcher应用程序的启动过程。        Android系统的Home应用程序Launcher是由ActivityManagerService启动... 2011-09-16 00:58 (86239) (62)
laoluo-40 | Android系统进程Zygote启动过程的源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6768304 | parentid:laoluo-33 description:在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote进程孕育（fork）出来的，这也许就是为什么要把它称为Zygote（受精卵）的原因吧。由于Zygote进程在Android系统中有着如此重要的地位，本文将详细分析它的启动过程。        在前面一篇文章Android应用程序进程启动过程的源代码分析中，我们看到了，当ActivityManager... 2011-09-19 00:59 (74435) (32)
laoluo-41 | Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析 | http://blog.csdn.net/luoshengyang/article/details/6786239 | parentid:laoluo-33 description:Android系统的运行时库层代码是用C++来编写的，用C++来写代码最容易出错的地方就是指针了，一旦使用不当，轻则造成内存泄漏，重则造成系统崩溃。不过系统为我们提供了智能指针，避免出现上述问题，本文将系统地分析Android系统智能指针（轻量级指针、强指针和弱指针）的实现原理。        在使用C++来编写代码的过程中，指针使用不当造成内存泄漏一般就是因为new了一个对象并且使用完之后，忘记... 2011-09-23 00:59 (64625) (61)
laoluo-42 | Android应用程序消息处理机制（Looper、Handler）分析 | http://blog.csdn.net/luoshengyang/article/details/6817933 | parentid:laoluo-33 description:Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行，本文将详细分析Android应用程序的消息处理机制。        前面我们学习Android应用程序中的Activity启动（Android应用程序启动过程源代码分析和A... 2011-09-29 00:58 (79186) (100)
laoluo-43 | Android应用程序键盘（Keyboard）消息处理机制分析 | http://blog.csdn.net/luoshengyang/article/details/6882903 | parentid:laoluo-33 description:在Android系统中，键盘按键事件是由WindowManagerService服务来管理的，然后再以消息的形式来分发给应用程序处理，不过和普通消息不一样，它是由硬件中断触发的；在上一篇文章《Android应用程序消息处理机制（Looper、Handler）分析》中，我们分析了Android应用程序的消息处理机制，本文将结合这种消息处理机制来详细分析Android应用程序是如何获得键盘按键消息的。... 2011-10-24 00:59 (104172) (205)
laoluo-44 | Android应用程序线程消息循环模型分析 | http://blog.csdn.net/luoshengyang/article/details/6905587 | parentid:laoluo-33 description:我们知道，Android应用程序是通过消息来驱动的，即在应用程序的主线程（UI线程）中有一个消息循环，负责处理消息队列中的消息。我们也知道，Android应用程序是支持多线程的，即可以创建子线程来执行一些计算型的任务，那么，这些子线程能不能像应用程序的主线程一样具有消息循环呢？这些子线程又能不能往应用程序的主线程中发送消息呢？本文将分析Android应用程序线程消息处理模型，为读者解答这两个问题... 2011-10-31 01:00 (34437) (42)
laoluo-45 | Android系统匿名共享内存（Anonymous Shared Memory）C++调用接口分析 | http://blog.csdn.net/luoshengyang/article/details/6939890 | parentid:laoluo-33 description:在Android系统中，针对移动设备内存空间有限的特点，提供了一种在进程间共享数据的机制：匿名共享内存，它能够辅助内存管理系统来有效地管理内存，它的实现原理我们在前面已经分析过了。为了方便使用匿名共享内存机制，系统还提供了Java调用接口（MemoryFile）和C++调用接口（MemoryHeapBase、MemoryBase），Java接口在前面也已经分析过了，本文中将继续分析它的C++接口。... 2011-11-07 00:58 (33792) (23)
laoluo-46 | Android应用程序组件Content Provider简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/6946067 | description:在Android系统中，Content Provider作为应用程序四大组件之一，它起到在应用程序之间共享数据的作用，同时，它还是标准的数据访问接口。前面的一系列文章已经分析过Android应用程序的其它三大组件（Activity、Service和Broadcast Receiver）了，本文将简要介绍Content Provider组件在Android应用程序设计中的地位，为进一步学习打好基础。... 2011-11-14 01:03 (39994) (32)
laoluo-47 | Android应用程序组件Content Provider应用实例 | http://blog.csdn.net/luoshengyang/article/details/6950440 | parentid:laoluo-46 description:上文简要介绍了Android应用程序组件Content Provider在应用程序间共享数据的原理，但是没有进一步研究它的实现。本文将实现两个应用程序，其中一个以Content Provider的形式来提供数据访问入口，另一个通过这个Content Provider来访问这些数据。本文的例子不仅可以为下文分析Content Provider的实现原理准备好使用情景，还可以学习到它的一个未公开接口。... 2011-11-21 00:58 (54316) (57)
laoluo-48 | Android应用程序组件Content Provider的启动过程源代码分析 | http://blog.csdn.net/luoshengyang/article/details/6963418 | parentid:laoluo-46 description:通过前面的学习，我们知道在Android系统中，Content Provider可以为不同的应用程序访问相同的数据提供统一的入口。Content Provider一般是运行在独立的进程中的，每一个Content Provider在系统中只有一个实例存在，其它应用程序首先要找到这个实例，然后才能访问它的数据。那么，系统中的Content Provider实例是由谁来负责启动的呢？本文将回答这个问题。... 2011-11-28 00:58 (36988) (43)
laoluo-49 | Android应用程序组件Content Provider在应用程序之间共享数据的原理分析 | http://blog.csdn.net/luoshengyang/article/details/6967204 | parentid:laoluo-46 description:在Android系统中，不同的应用程序是不能直接读写对方的数据文件的，如果它们想共享数据的话，只能通过Content Provider组件来实现。那么，Content Provider组件又是如何突破应用程序边界权限控制来实现在不同的应用程序之间共享数据的呢？在前面的文章中，我们已经简要介绍过它是通过Binder进程间通信机制以及匿名共享内存机制来实现的，在本文中，我们将详细分析它的数据共享原理。... 2011-12-05 01:00 (34515) (17)
laoluo-50 | Android应用程序组件Content Provider的共享数据更新通知机制分析 | http://blog.csdn.net/luoshengyang/article/details/6985171 | parentid:laoluo-46 description:在Android系统中，应用程序组件Content Provider为不同的应用程序实现数据共享提供了基础设施，它主要通过Binder进程间通信机制和匿名共享内存机制来实现的。关于数据共享的另一个话题便是数据更新通知机制了，即如果一个应用程序对共享数据做了修改，它应该如何通知其它正在使用这些共享数据的应用程序呢？本文将分析Content Provider的共享数据更新通知机制，为读者解答这个问题。... 2011-12-12 00:58 (36725) (33)
laoluo-51 | Android系统的开机画面显示过程分析 | http://blog.csdn.net/luoshengyang/article/details/7691321 | parentid:laoluo-46 description:好几个月都没有更新过博客了，从今天开始，老罗将尝试对Android系统的UI实现作一个系统的分析，也算是落实之前所作出的承诺。提到Android系统的UI，我们最先接触到的便是系统在启动过程中所出现的画面了。Android系统在启动的过程中，最多可以出现三个画面，每一个画面都用来描述一个不同的启动阶段。本文将详细分析这三个开机画面的显示过程，以便可以开启我们对Android系统UI实现的分析之路。... 2012-07-09 00:56 (99631) (134)
laoluo-52 | Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析 | http://blog.csdn.net/luoshengyang/article/details/7747932 | parentid:laoluo-46 description:前面在介绍Android系统的开机画面时提到，Android设备的显示屏被抽象为一个帧缓冲区，而Android系统中的SurfaceFlinger服务就是通过向这个帧缓冲区写入内容来绘制应用程序的用户界面的。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。本文将详细分析Gralloc模块的实现，为后续分析SurfaceFlinger服务的实现打下基础。... 2012-07-23 01:25 (62842) (90)
laoluo-53 | Android应用程序与SurfaceFlinger服务的关系概述和学习计划 | http://blog.csdn.net/luoshengyang/article/details/7846923 | description:SurfaceFlinger服务负责绘制Android应用程序的UI，它的实现相当复杂，要从正面分析它的实现不是一件容易的事。既然不能从正面分析，我们就想办法从侧面分析。说到底，无论SurfaceFlinger服务有多复杂，它都是为Android应用程序服务的，因此，我们就从Android应用程序与SurfaceFlinger服务的关系入手，来概述和制定SurfaceFlinger服务的学习计划。... 2012-08-13 00:56 (71644) (65)
laoluo-54 | Android应用程序与SurfaceFlinger服务的连接过程分析 | http://blog.csdn.net/luoshengyang/article/details/7857163 | parentid:laoluo-53 description:前文在描述Android应用程序和SurfaceFlinger服务的关系时提到，每一个有UI的Android应用程序都需要与SurfaceFlinger服务建立一个连接，以便可以通过这个连接来请求SurfaceFlinger服务为它创建和渲染Surface。在本文中，我们将以Android系统的开机动画应用程序为例，详细描述Android应用程序是如何与SurfaceFlinger服务建立连接的。... 2012-08-20 00:56 (38778) (31)
laoluo-55 | Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/7867340 | parentid:laoluo-53 description:在前面一篇文章中，我们分析了Android应用程序与SurfaceFlinger服务的连接过程。Android应用程序成功连接上SurfaceFlinger服务之后，还需要一块匿名共享内存来和SurfaceFlinger服务共享它的UI元数据，以便使得SurfaceFlinger服务可以正确地为它创建以及渲染Surface。在本文中，我们将详细地分析这块用来保存UI元数据的匿名共享内存的创建过程。... 2012-08-27 00:56 (28791) (17)
laoluo-56 | Android应用程序请求SurfaceFlinger服务创建Surface的过程分析 | http://blog.csdn.net/luoshengyang/article/details/7884628 | parentid:laoluo-53 description:前面我们已经学习过Android应用程序与SurfaceFlinger服务的连接过程了。连接上SurfaceFlinger服务之后，Android应用程序就可以请求SurfaceFlinger服务创建Surface。而当有了Surface后，Android应用程序就可以用来渲染自己的UI了。在本文中，我们将详细分析Android应用程序请求SurfaceFlinger服务创建Surface的过程。... 2012-09-03 01:01 (37069) (41)
laoluo-57 | Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析 | http://blog.csdn.net/luoshengyang/article/details/7932268 | parentid:laoluo-53 description:在前面一篇文章中，我们分析了Android应用程序请求SurfaceFlinger服务创建Surface的过程。有了Surface之后，Android应用程序就可以在上面绘制自己的UI了，接着再请求SurfaceFlinger服务将这个已经绘制好了UI的Surface渲染到设备显示屏上去。在本文中，我们就将详细分析Android应用程序请求SurfaceFlinger服务渲染Surface的过程。... 2012-09-17 00:56 (47919) (35)
laoluo-58 | Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/8010977 | description:前面我们从Android应用程序与SurfaceFlinger服务的关系出发，从侧面简单学习了SurfaceFlinger服务。有了这些预备知识之后，我们就可以从正面来分析SurfaceFlinger服务的实现原理了。SurfaceFlinger服务负责管理系统的帧缓冲区设备，并且负责渲染系统的UI，即各个应用程序的UI。在本文中，我们就简要介绍SurfaceFlinger服务，并且制定学习计划。... 2012-09-26 00:55 (43672) (13)
laoluo-59 | Android系统Surface机制的SurfaceFlinger服务的启动过程分析 | http://blog.csdn.net/luoshengyang/article/details/8022957 | parentid:laoluo-58 description:在前面一篇文章中，我们简要介绍了Android系统Surface机制中的SurfaceFlinger服务。SurfaceFlinger服务是在System进程中启动的，并且负责统一管理设备的帧缓冲区。SurfaceFlinger服务在启动的过程中，会创建两个线程，其中一个线程用来监控控制台事件，而另外一个线程用来渲染系统的UI。在本文中，我们就将详细分析SurfaceFlinger服务的启动过程。... 2012-09-29 14:48 (40380) (10)
laoluo-60 | Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析 | http://blog.csdn.net/luoshengyang/article/details/8046659 | parentid:laoluo-58 description:在前文中，我们分析了SurfaceFlinger服务的启动过程。SurfaceFlinger服务在启动的过程中，会对系统的硬件帧缓冲区进行初始化。由于系统的硬件帧缓冲区一般只有一个，并且不是谁都可以随便访问的，因此，它就需要由一个服务来统一管理。在Android系统中，这个服务便是SurfaceFlinger。在本文中，我们就详细分析SurfaceFlinger服务是如何管理系统的硬件帧缓冲区的。... 2012-10-15 00:56 (45564) (48)
laoluo-61 | Android系统Surface机制的SurfaceFlinger服务的线程模型分析 | http://blog.csdn.net/luoshengyang/article/details/8062945 | parentid:laoluo-58 description:在前面两篇文章中，我们分析了SurfaceFlinger服务的启动过程以及SurfaceFlinger服务初始化硬件帧缓冲区的过程。从这两个过程可以知道，SurfaceFlinger服务在启动的过程中，一共涉及到了三种类型的线程，它们分别是Binder线程、UI渲染线程和控制台事件监控线程。在本文中，我们就将详细分SurfaceFlinger服务的线程模型，即上述三种类型的线程是如何运行和交互的。... 2012-10-22 00:55 (29532) (23)
laoluo-62 | Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析 | http://blog.csdn.net/luoshengyang/article/details/8079456 | parentid:laoluo-58 description:在前面的一系列文章中，我们学习了Android应用程序与SurfaceFlinger服务的关系，以及SurfaceFlinger服务的启动过程、初始化硬件帧缓冲区的过程、线程模型。SurfaceFlinger服务所做的一切都是为了给Android应用程序提服务的，即为Android应用程序渲染它们的UI。在本文中，我们就详细分析SurfaceFlinger服务渲染Android应用程序UI的过程。... 2012-11-05 00:59 (38155) (51)
laoluo-63 | Android应用程序窗口（Activity）实现框架简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/8170307 | description:前面我们学习了SurfaceFlinger服务的实现原理。有了这个基础之后，从本文开始，我们就可以分析Android系统在Java层的UI实现了。我们知道，在Android应用程序的四大组件中，只有Activity组件与UI相关，它描述的是应用程序窗口，因此，我们就通过它的UI实现来分析Android系统在Java层的UI实现。本文主要是对Activity组件的UI实现作简要介绍以及制定学习计划。... 2012-11-19 00:56 (58434) (41)
laoluo-64 | Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8201936 | parentid:laoluo-63 description:在前文中，我们简要介绍了Android应用程序窗口的框架。Android应用程序窗口在运行的过程中，需要访问一些特定的资源或者类。这些特定的资源或者类构成了Android应用程序的运行上下文环境，Android应用程序窗口可以通过一个Context接口来访问它，这个Context接口也是我们在开发应用程序时经常碰到的。在本文中，我们就将详细分析Android应用程序窗口的运行上下文环境的创建过程。... 2012-11-26 00:55 (43400) (33)
laoluo-65 | Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8223770 | parentid:laoluo-63 description:在前文中，我们分析了Android应用程序窗口的运行上下文环境的创建过程。由此可知，每一个Activity组件都有一个关联的ContextImpl对象，同时，它还关联有一个Window对象，用来描述一个具体的应用程序窗口。由此又可知，Activity只不过是一个高度抽象的UI组件，它的具体UI实现其实是由其它的一系列对象来实现的。在本文中，我们就将详细分析Android应用程序窗口对象的创建过程。... 2012-12-03 00:55 (46520) (29)
laoluo-66 | Android应用程序窗口（Activity）的视图对象（View）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8245546 | parentid:laoluo-63 description:从前文可知道，每一个Activity组件都有一个关联的Window对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个View对象，用来描述应用程序窗口的视图。应用程序窗口视图是真正用来实现UI内容和布局的，也就是说，每一个Activity组件的UI内容和布局都是通过与其所关联的一个Window对象的内部的一个View对象来实现的。在本文中，我们就详细分析应用程序窗口视图的创建过程。... 2012-12-10 00:55 (54289) (33)
laoluo-67 | Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析 | http://blog.csdn.net/luoshengyang/article/details/8275938 | parentid:laoluo-63 description:在前两文中，我们分析了Activity组件的窗口对象和视图对象的创建过程。Activity组件在其窗口对象和视图对象创建完成之后，就会请求与WindowManagerService建立一个连接，即请求WindowManagerService为其增加一个WindowState对象，用来描述它的窗口状态。在本文中，我们就详细分析Activity组件与WindowManagerService的连接过程。... 2012-12-17 00:57 (41668) (35)
laoluo-68 | Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8303098 | parentid:laoluo-63 description:在前文中，我们分析了应用程序窗口连接到WindowManagerService服务的过程。在这个过程中，WindowManagerService服务会为应用程序窗口创建过一个到SurfaceFlinger服务的连接。有了这个连接之后，WindowManagerService服务就可以为应用程序窗口创建绘图表面了，以便可以用来渲染窗口的UI。在本文中，我们就详细分析应用程序窗口的绘图表面的创建过程。... 2012-12-24 00:55 (40238) (19)
laoluo-69 | Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析 | http://blog.csdn.net/luoshengyang/article/details/8372924 | parentid:laoluo-63 description:在前面一篇文章中，我们分析了Android应用程序窗口的绘图表面的创建过程。Android应用程序窗口的绘图表面在创建完成之后，我们就可以从上到下地绘制它里面的各个视图了，即各个UI元素了。不过在绘制这些UI元素之前，我们还需要从上到下地测量它们实际所需要的大小，以及对它们的位置进行合适的安排，即对它们进行合适的布局。在本文中，我们就将详细地分析Android应用程序窗口的测量、布局以及绘制过程。... 2012-12-31 00:55 (62460) (52)
laoluo-70 | Android窗口管理服务WindowManagerService的简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/8462738 | description:在前一个系列文章中，我们从个体的角度来分析了Android应用程序窗口的实现框架。事实上，如果我们从整体的角度来看，Android应用程序窗口的实现要更复杂，因为它们的类型和作用不同，且会相互影响。在Android系统中，对系统中的所有窗口进行管理是窗口管理服务WindowManagerService的职责。在本文中，我们就将简要介绍WindowManagerService的职能以及制定学习计划。... 2013-01-06 16:56 (44038) (22)
laoluo-71 | Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析 | http://blog.csdn.net/luoshengyang/article/details/8479101 | parentid:laoluo-70 description:在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。本文将详细分析WindowManagerService服务计算Activity窗口大小的过程。... 2013-01-14 00:56 (53451) (36)
laoluo-72 | Android窗口管理服务WindowManagerService对窗口的组织方式分析 | http://blog.csdn.net/luoshengyang/article/details/8498908 | parentid:laoluo-70 description:我们知道，在Android系统中，Activity是以堆栈的形式组织在ActivityManagerService服务中的。与Activity类似，Android系统中的窗口也是以堆栈的形式组织在WindowManagerService服务中的，其中，Z轴位置较低的窗口位于Z轴位置较高的窗口的下面。在本文中，我们就详细分析WindowManagerService服务是如何以堆栈的形式来组织窗口的。... 2013-01-21 01:01 (38355) (20)
laoluo-73 | Android窗口管理服务WindowManagerService对输入法窗口（Input Method Window）的管理分析 | http://blog.csdn.net/luoshengyang/article/details/8526644 | parentid:laoluo-70 description:在Android系统中，输入法窗口是一种特殊类型的窗口，它总是位于需要使用输入法的窗口的上面。也就是说，一旦WindowManagerService服务检测到焦点窗口需要使用输入法，那么它就会调整输入法窗口在窗口堆栈中的位置，使得输入法窗口位于在焦点窗口的上面，这样用户可以通过输入法窗口来录入字母或者文字。本文就将详细分析WindowManagerService服务是如何管理系统中的输入法窗口的。... 2013-01-28 00:57 (32891) (18)
laoluo-74 | Android窗口管理服务WindowManagerService对壁纸窗口（Wallpaper Window）的管理分析 | http://blog.csdn.net/luoshengyang/article/details/8550820 | parentid:laoluo-70 description:在Android系统中，壁纸窗口和输入法窗口一样，都是一种特殊类型的窗口，而且它们都是喜欢和一个普通的Activity窗口缠绵在一起。大家可以充分地想象这样的一个3W场景：输入法窗口在上面，壁纸窗口在下面，Activity窗口夹在它们的中间。在前面一篇文章中，我们已经分析过输入法窗口是如何压在Activity窗口上面的了。在这篇文章中，我们就将继续分析壁纸窗口是如何贴在Activity窗口下面的。... 2013-02-04 00:56 (33700) (11)
laoluo-75 | Android窗口管理服务WindowManagerService计算窗口Z轴位置的过程分析 | http://blog.csdn.net/luoshengyang/article/details/8570428 | parentid:laoluo-70 description:通过前面几篇文章的学习，我们知道了在Android系统中，无论是普通的Activity窗口，还是特殊的输入法窗口和壁纸窗口，它们都是被WindowManagerService服务组织在一个窗口堆栈中的，其中，Z轴位置较大的窗口排列在Z轴位置较小的窗口的上面。有了这个窗口堆栈之后，WindowManagerService服务就可以按照一定的规则计算每一个窗口的Z轴位置了，本文就详细分析这个计算过程。... 2013-02-09 23:55 (28890) (7)
laoluo-76 | Android窗口管理服务WindowManagerService显示Activity组件的启动窗口（Starting Window）的过程分析 | http://blog.csdn.net/luoshengyang/article/details/8577789 | parentid:laoluo-70 description:在Android系统中，Activity组件在启动之后，并且在它的窗口显示出来之前，可以显示一个启动窗口。这个启动窗口可以看作是Activity组件的预览窗口，是由WindowManagerService服务统一管理的，即由WindowManagerService服务负责启动和结束。在本文中，我们就详细分析WindowManagerService服务启动和结束Activity组件的启动窗口的过程。... 2013-02-18 00:56 (37420) (4)
laoluo-77 | Android窗口管理服务WindowManagerService切换Activity窗口（App Transition）的过程分析 | http://blog.csdn.net/luoshengyang/article/details/8596449 | parentid:laoluo-70 description:在Android系统中，同一时刻只有一个Activity组件是处于激活状态的，因此，当ActivityManagerService服务激活了一个新的Activity组件时，它就需要通知WindowManagerService服务将该Activity组件的窗口显示出来，这会涉及到将焦点和屏幕等资源从前一个激活的Activity组件切换到后一个激活的Activity组件的过程，本文就详细分析这个过程。... 2013-02-25 00:57 (38133) (11)
laoluo-78 | Android窗口管理服务WindowManagerService显示窗口动画的原理分析 | http://blog.csdn.net/luoshengyang/article/details/8611754 | parentid:laoluo-70 description:在前一文中，我们分析了Activity组件的切换过程。从这个过程可以知道，所有参与切换操作的窗口都会被设置切换动画。事实上，一个窗口在打开（关闭）的过程中，除了可能会设置切换动画之外，它本身也可能会设置有进入（退出）动画。再进一步地，如果一个窗口是附加在另外一个窗口之上的，那么被附加窗口所设置的动画也会同时传递给该窗口。本文就详细分析WindowManagerService服务显示窗口动画的原理。... 2013-03-04 00:56 (38116) (19)
laoluo-79 | Android控件TextView的实现原理分析 | http://blog.csdn.net/luoshengyang/article/details/8636153 | parentid:laoluo-70 description:在前面一个系列的文章中，我们以窗口为单位，分析了WindowManagerService服务的实现。同时，在再前面一个系列的文章中，我们又分析了窗口的组成。简单来说，窗口就是由一系列的视图按照一定的布局组织起来的。实际上，每一个视图都是一个控件，这些控制可以将自己的UI绘制在窗口的绘图表面上，同时还可以与用户进行交互，即获得用户的键盘或者触摸屏输入。在本文中，我们就详细分析窗口控件的上述实现原理。... 2013-03-11 00:56 (69550) (32)
laoluo-80 | Android视图SurfaceView的实现原理分析 | http://blog.csdn.net/luoshengyang/article/details/8661317 | parentid:laoluo-70 description:在Android系统中，有一种特殊的视图，称为SurfaceView，它拥有独立的绘图表面，即它不与其宿主窗口共享同一个绘图表面。由于拥有独立的绘图表面，因此SurfaceView的UI就可以在一个独立的线程中进行绘制。又由于不会占用主线程资源，SurfaceView一方面可以实现复杂而高效的UI，另一方面又不会导致用户输入得不到及时响应。在本文中，我们就详细分析SurfaceView的实现原理。... 2013-03-16 16:57 (114953) (58)
laoluo-81 | Android资源管理框架（Asset Manager）简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/8738877 | description:Android应用程序主要由两部分内容组成：代码和资源。资源主要就是指那些与UI相关的东西，例如UI布局、字符串和图片等。代码和资源分开可以使得应用程序在运行时根据实际需要来组织UI。这样就可使得应用程序只需要编译一次，就可以支持不同的UI布局。这种特性使得应用程序在运行时可以适应不同的屏幕大小和密度，以及不同的国家和语言等。在本文中，我们就简要介绍Android的资源管理框架，以及制定学习计划。... 2013-04-01 00:56 (55235) (34)
laoluo-82 | Android应用程序资源的编译和打包过程分析 | http://blog.csdn.net/luoshengyang/article/details/8744683 | parentid:laoluo-81 description:我们知道，在一个APK文件中，除了有代码文件之外，还有很多资源文件。这些资源文件是通过Android资源打包工具aapt（Android Asset Package Tool）打包到APK文件里面的。在打包之前，大部分文本格式的XML资源文件还会被编译成二进制格式的XML资源文件。在本文中，我们就详细分析XML资源文件的编译和打包过程，为后面深入了解Android系统的资源管理框架打下坚实的基础。... 2013-04-15 00:57 (110544) (50)
laoluo-83 | Android应用程序资源管理器（Asset Manager）的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8791064 | parentid:laoluo-81 description:在前面一篇文章中，我们分析了Android应用程序资源的编译和打包过程，最终得到的应用程序资源就与应用程序代码一起打包在一个APK文件中。Android应用程序在运行的过程中，是通过一个称为AssetManager的资源管理器来读取打包在APK文件里面的资源文件的。在本文中，我们就将详细分析Android应用程序资源管理器的创建以及初始化过程，为接下来的一篇文章分析应用程序资源的读取过程打下基础。... 2013-04-22 00:56 (51994) (23)
laoluo-84 | Android应用程序资源的查找过程分析 | http://blog.csdn.net/luoshengyang/article/details/8806798 | parentid:laoluo-81 description:我们知道，在Android系统中，每一个应用程序一般都会配置很多资源，用来适配不同密度、大小和方向的屏幕，以及适配不同的国家、地区和语言等等。这些资源是在应用程序运行时自动根据设备的当前配置信息进行适配的。这也就是说，给定一个相同的资源ID，在不同的设备配置之下，查找到的可能是不同的资源。这个资源查找过程对应用程序来说，是完全透明的。在本文中，我们就详细分析资源管理框架是如何根据ID来查找资源的。... 2013-04-28 00:56 (55782) (30)
laoluo-85 | Dalvik虚拟机简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/8852432 | description:我们知道，Android应用程序是运行在Dalvik虚拟机里面的，并且每一个应用程序对应有一个单独的Dalvik虚拟机实例。除了指令集和类文件格式不同，Dalvik虚拟机与Java虚拟机共享有差不多的特性，例如，它们都是解释执行，并且支持即时编译（JIT）、垃圾收集（GC）、Java本地方法调用（JNI）和Java远程调试协议（JDWP）等。本文对Dalvik虚拟机进行简要介绍，以及制定学习计划。... 2013-05-06 00:57 (53988) (40)
laoluo-86 | Dalvik虚拟机的启动过程分析 | http://blog.csdn.net/luoshengyang/article/details/8885792 | parentid:laoluo-85 description:在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。在本文中，我们就分析Dalvik虚拟机在Zygote进程中的启动过程。... 2013-05-13 00:57 (49398) (30)
laoluo-87 | Dalvik虚拟机的运行过程分析 | http://blog.csdn.net/luoshengyang/article/details/8914953 | parentid:laoluo-85 description:在前面一篇文章中，我们分析了Dalvik虚拟机在Zygote进程中的启动过程。Dalvik虚拟机启动完成之后，也就是在各个子模块初始化完成以及加载了相应的Java核心类库之后，就是可以执行Java代码了。当然，Dalvik虚拟机除了可以执行Java代码之外，还可以执行Native代码，也就是C和C++代码。在本文中，我们就将继续以Zygote进程的启动过程为例，来分析Dalvik虚拟机的运行过程。... 2013-05-20 00:57 (45003) (25)
laoluo-88 | Dalvik虚拟机JNI方法的注册过程分析 | http://blog.csdn.net/luoshengyang/article/details/8923483 | parentid:laoluo-85 description:在前面一文中，我们分析了Dalvik虚拟机的运行过程。从中可以知道，Dalvik虚拟机在调用一个成员函数的时候，如果发现该成员函数是一个JNI方法，那么就会直接跳到它的地址去执行。也就是说，JNI方法是直接在本地操作系统上执行的，而不是由Dalvik虚拟机解释器执行。由此也可看出，JNI方法是Android应用程序与本地操作系统直接进行通信的一个手段。在本文中，我们就详细分析JNI方法的注册过程。... 2013-05-27 00:57 (42026) (30)
laoluo-89 | Dalvik虚拟机进程和线程的创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/8923484 | parentid:laoluo-85 description:我们知道，在Android系统中，Dalvik虚拟机是运行Linux内核之上的。如果我们把Dalvik虚拟机看作是一台机器，那么它也有进程和线程的概念。事实上，我们的确是可以在Java代码中创建进程和线程，也就是Dalvik虚拟机进程和线程。那么，这些Dalvik虚拟机所创建的进程和线程与其宿主Linux内核的进程和线程有什么关系呢？本文将通过Dalvik虚拟机进程和线程的创建过程来回答这个问题。... 2013-06-03 01:03 (36529) (34)
laoluo-90 | 从NDK在非Root手机上的调试原理探讨Android的安全机制 | http://blog.csdn.net/luoshengyang/article/details/17131835 | parentid:laoluo-85 description:最近忙着研究Android的安全技术，好长时间没有写博客了，准备回归老本行：Read the funcking android source code。这两天看NDK文档时，看到一句“Native debugging ... does not require root or privileged access, aslong as your application is debuggable”。咦，NDK调试不是通过ptrace实现的么？在非Root的手机上是怎么进行ptrace呢？借这两问题正好可以介绍一... 2013-12-09 01:02 (32763) (30)
laoluo-91 | Android ART运行时无缝替换Dalvik虚拟机的过程分析 | http://blog.csdn.net/luoshengyang/article/details/18006645 | parentid:laoluo-85 description:Android 4.4发布了一个ART运行时，准备用来替换掉之前一直使用的Dalvik虚拟机，希望籍此解决饱受诟病的性能问题。老罗不打算分析ART的实现原理，只是很有兴趣知道ART是如何无缝替换掉原来的Dalvik虚拟机的。毕竟在原来的系统中，大量的代码都是运行在Dalvik虚拟机里面的。开始觉得这个替换工作是挺复杂的，但是分析了相关代码之后，发现思路是很清晰的。本来就详细分析这个无缝的替换过程。... 2014-01-13 00:59 (58690) (75)
laoluo-92 | Android源代码仓库及其管理工具Repo分析 | http://blog.csdn.net/luoshengyang/article/details/18195205 | parentid:laoluo-85 description:软件工程由于需要不断迭代开发，因此要对源代码进行版本管理。Android源代码工程（AOSP）也不例外，它采用Git来进行版本管理。AOSP作为一个大型开放源代码工程，由许许多多子项目组成，因此不能简单地用Git进行管理，它在Git的基础上建立了一套自己的代码仓库，并且使用工具Repo进行管理。工欲善其事，必先利其器。本文就对AOSP代码仓库及其管理工具repo进行分析，以便提高我们日常开发效率。... 2014-01-20 00:58 (39753) (28)
laoluo-93 | Android编译系统简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/18466779 | description:在Android源码环境中，我们开发好一个模块后，再写一个Android.mk文件，就可通过m/mm/mmm/make等命令进行编译。此外，通过make命令还可制作各种系统镜像文件，例如system.img、boot.img和recovery.img等。这一切都得益于Android编译系统，它为我们处理了各种依赖关系，以及提供各种有用工具。本文对Android编译系统进行简单介绍以及制定学习计划。... 2014-02-10 01:02 (37474) (26)
laoluo-94 | Android编译系统环境初始化过程分析 | http://blog.csdn.net/luoshengyang/article/details/18928789 | parentid:laoluo-93 description:Android源代码在编译之前，要先对编译环境进行初始化，其中最主要就是指定编译的类型和目标设备的型号。Android的编译类型主要有eng、userdebug和user三种，而支持的目标设备型号则是不确定的，它们由当前的源码配置情况所决定。为了确定源码支持的所有目标设备型号，Android编译系统在初始化的过程中，需要在特定的目录中加载特定的配置文件。接下来本文就对上述的初始化过程进行详细分析。... 2014-02-17 01:00 (41229) (48)
laoluo-95 | Android源代码编译命令m/mm/mmm/make分析 | http://blog.csdn.net/luoshengyang/article/details/19023609 | parentid:laoluo-93 description:在前文中，我们分析了Android编译环境的初始化过程。Android编译环境初始化完成后，我们就可以用m/mm/mmm/make命令编译源代码了。当然，这要求每一个模块都有一个Android.mk文件。Android.mk实际上是一个Makefile脚本，用来描述模块编译信息。Android编译系统通过整合Android.mk文件完成编译过程。本文就对Android源代码的编译过程进行详细分析。... 2014-03-10 00:57 (53741) (20)
laoluo-96 | Android系统镜像文件的打包过程分析 | http://blog.csdn.net/luoshengyang/article/details/20501657 | parentid:laoluo-93 description:在前面一篇文章中，我们分析了Android模块的编译过程。当Android系统的所有模块都编译好之后，我们就可以对编译出来的模块文件进行打包了。打包结果是获得一系列的镜像文件，例如system.img、boot.img、ramdisk.img、userdata.img和recovery.img等。这些镜像文件最终可以烧录到手机上运行。在本文中，我们就详细分析Android系统的镜像文件的打包过程。... 2014-04-14 01:01 (33150) (16)
laoluo-97 | 从CM刷机过程和原理分析Android系统结构 | http://blog.csdn.net/luoshengyang/article/details/29688041 | parentid:laoluo-93 description:前面101篇文章都是分析Android系统源码，似乎不够接地气。如果能让Android系统源码在真实设备上跑跑看效果，那该多好。这不就是传说中的刷ROM吗？刷ROM这个话题是老罗以前一直避免谈的，因为觉得没有全面了解Android系统前就谈ROM是不完整的。写完了101篇文章后，老罗觉得第102篇文章该谈谈这个话题了，并且选择CM这个有代表性的ROM来谈，目标是加深大家对Android系统的了解。... 2014-06-16 01:01 (50634) (47)
laoluo-98 | SEAndroid安全机制简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/35392905 | description:与iOS相比，Android最被人诟病的是其流畅性和安全性。然而，从4.0开始，Android不遗余力地改善其流畅性。特别是在即将发布的L版本中，用ART替换了Dalvik，相信会越来越流畅。至于安全性，Android也没有遗忘。从4.3开始，Android引入了一套基于SELinux的安全机制，称为SEAndroid，来加强系统安全性。接下来我们就对SEAndroid进行简要介绍和制定学习计划。... 2014-06-30 00:58 (31265) (29)
laoluo-99 | SEAndroid安全机制框架分析 | http://blog.csdn.net/luoshengyang/article/details/37613135 | parentid:laoluo-98 description:我们知道，Android系统基于Linux实现。针对传统Linux系统，NSA开发了一套安全机制SELinux，用来加强安全性。然而，由于Android系统有着独特的用户空间运行时，因此SELinux不能完全适用于Android系统。为此，NSA针对Android系统，在SELinux基础上开发了SEAndroid。本文就对SEAndroid安全机制框架进行分析，以便后面可以更好地分析其实现细节。... 2014-07-14 01:00 (41238) (23)
laoluo-100 | SEAndroid安全机制中的文件安全上下文关联分析 | http://blog.csdn.net/luoshengyang/article/details/37749383 | parentid:laoluo-98 description:前面一篇文章提到，SEAndroid是一种基于安全策略的MAC安全机制。这种安全策略实施在主体和客体的安全上下文之上。这意味着安全策略在实施之前，SEAndroid安全机制中的主休和客体是已经有安全上下文的。在SEAndroid安全机制中，主体一般就是进程，而客体一般就是文件。文件的安全上下文的关联有不同的方式。本文主要分析文件安全上下文的设置过程，接下来的一篇文章再分析进程安全上下文的设置过程。... 2014-07-21 00:59 (20021) (13)
laoluo-101 | SEAndroid安全机制中的进程安全上下文关联分析 | http://blog.csdn.net/luoshengyang/article/details/38054645 | parentid:laoluo-98 description:前面一篇文章分析了文件安全上下文关联过程。但是在SEAndroid中，除了要给文件关联安全上下文外，还需要给进程关联安全上下文，因为只有当进程和文件都关联安全上下文之后，SEAndroid安全策略才能发挥作用。也就是说，当一个进程试图访问一个文件时，SEAndroid会将进程和文件的安全上下文提取出来，根据安全策略规则，决定是否允许访问。本文就详细分析SEAndroid的进程安全上下文的关联过程。... 2014-07-28 00:59 (16799) (21)
laoluo-102 | SEAndroid安全机制对Android属性访问的保护分析 | http://blog.csdn.net/luoshengyang/article/details/38102011 | parentid:laoluo-98 description:Android系统通过属性暴露设备和运行时信息，并且可以通过设置属性来控制系统行为。因此，属性也像文件一样，是一种需要保护的资源。在启用SEAndroid之前，敏感属性只能被预先设定的进程进行设置。启用SEAndroid之后，敏感属性会进一步被SEAndroid安全策略保护。这样就可以更有效地保护系统属性了。在本文中，我们就详细分析SEAndroid安全机制对Android属性设置保护提供的支持。... 2014-08-04 00:57 (14192) (13)
laoluo-103 | SEAndroid安全机制对Binder IPC的保护分析 | http://blog.csdn.net/luoshengyang/article/details/38326729 | parentid:laoluo-98 description:在SEAndroid安全机制中，除了文件和属性，还有Binder IPC需要保护。Binder IPC是Android系统的灵魂，使用得相当广泛又频繁。例如，应用程序都是Binder IPC请求访问系统服务和资源。因此，SEAndroid安全机制必须要为Binder IPC保驾护航，阻止一个进程非法访问其它进程的服务和资源。本文就详细分析SEAndroid安全机制对Binder IPC提供的支持。... 2014-08-11 00:58 (13819) (14)
laoluo-104 | Android运行时ART简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/39256813 | description:Android在4.4就已推出新运行时ART，准备替代用了有些时日的Dalvik。不过当时尚属测试版，主角仍是Dalvik。 直到今年的Google I/O大会，ART才正式取代Dalvik。这个消息在科技界引起不小轰动，也吸引不少技术人员对它的“技术分析”。可惜这些“技术分析”不过是引用了官方的数据和图表而已。这一系列文章将对ART进行真正的技术分析。老规矩，分析前先进行简要介绍和制定学习计划。... 2014-09-15 00:58 (31437) (45)
laoluo-105 | Android运行时ART加载OAT文件的过程分析 | http://blog.csdn.net/luoshengyang/article/details/39307813 | parentid:laoluo-104 description:在前面一文中，我们介绍了Android运行时ART，它的核心是OAT文件。OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。本文我们通过OAT文件的加载过程分析OAT文件的结构，为后面分析ART的工作原理打基础。... 2014-09-29 00:58 (36949) (39)
laoluo-106 | Android运行时ART加载类和方法的过程分析 | http://blog.csdn.net/luoshengyang/article/details/39533503 | parentid:laoluo-104 description:在前一篇文章中，我们通过分析OAT文件的加载过程，认识了OAT文件的格式，其中包含了原始的DEX文件。既然ART运行时执行的都是翻译DEX字节码后得到的本地机器指令了，为什么还需要在OAT文件中包含DEX文件，并且将它加载到内存去呢？这是因为ART运行时提供了Java虚拟机接口，而要实现Java虚拟机接口不得不依赖于DEX文件。本文就通过分析ART运行时加载类及其方法的过程来理解DEX文件的作用。... 2014-10-20 00:56 (24064) (24)
laoluo-107 | Android运行时ART执行类方法的过程分析 | http://blog.csdn.net/luoshengyang/article/details/40289405 | parentid:laoluo-104 description:在前面一篇文章中，我们分析了ART运行时加载类以及查找其方法的过程。一旦找到了目标类方法，我们就可以获得它的DEX字节码或者本地机器指令，这样就可以对它进行执行了。在ART运行时中，类方法的执行方式有两种。一种是像Dalvik虚拟机一样，将其DEX字节码交给解释器执行；另一种则是直接将其本地机器指令交给CPU执行。在本文中，我们就将通过分析ART运行时执行类方法的过程来理解ART运行时的运行原理。... 2014-11-10 01:00 (28456) (29)
laoluo-108 | Dalvik虚拟机垃圾收集机制简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/41338251 | description:伴随着“Dalvik is dead，long live Dalvik“这行AOSP代码提交日志，在Android5.0中，ART运行时取代了Dalvik虚拟机。虽然Dalvik虚拟机不再使用，但是它曾经的作用是不可磨灭的。因此，在研究ART运行时的垃圾收集机制之前，先理解Dalvik虚拟机的垃圾收集机制也是很重要和有帮助的。因此，本文就对Dalvik虚拟机的垃圾收集机进行简要介绍和制定学习计划。... 2014-11-24 01:01 (15609) (20)
laoluo-109 | Dalvik虚拟机Java堆创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/41581063 | parentid:laoluo-108 description:使用C/C++开发应用程序最令头痛的问题就是内存管理。慎不留神，要么内存泄漏，要么内存破坏。虚拟机要解决的问题之一就是帮助应用程序自动分配和释放内存。为了达到这个目的，虚拟机在启动的时候向操作系统申请一大块内存当作对象堆。之后当应用程序创建对象时，虚拟机就会在堆上分配合适的内存块。而当对象不再使用时，虚拟机就会将它占用的内存块归还给堆。Dalvik虚拟机也不例外，本文就分析它的Java堆创建过程。... 2014-12-01 01:03 (13476) (36)
laoluo-110 | Dalvik虚拟机为新创建对象分配内存的过程分析 | http://blog.csdn.net/luoshengyang/article/details/41688319 | parentid:laoluo-108 description:在前面一文中，我们分析了Dalvik虚拟机创建Java堆的过程。有了Java堆之后，Dalvik虚拟机就可以在上面为对象分配内存了。在Java堆为对象分配内存需要解决内存碎片和内存不足两个问题。要解决内存碎片问题，就要找到一块大小最合适的空闲内存分配给对象使用。而内存不足有可能是内存配额用完引起的，也有可能是垃圾没有及时回收引起的，要区别对待。本文就详细分析Dalvik虚拟机是如何解决这些问题的。... 2014-12-08 01:00 (12446) (18)
laoluo-111 | Dalvik虚拟机垃圾收集（GC）过程分析 | http://blog.csdn.net/luoshengyang/article/details/41822747 | parentid:laoluo-108 description:前面我们分析了Dalvik虚拟机堆的创建过程，以及Java对象在堆上的分配过程。这些知识都是理解Dalvik虚拟机垃圾收集过程的基础。垃圾收集是一个复杂的过程，它要将那些不再被引用的对象进行回收。一方面要求Dalvik虚拟机能够标记出哪些对象是不再被引用的。另一方面要求Dalvik虚拟机尽快地回收内存，避免应用程序长时间停顿。本文就将详细分析Dalvik虚拟机是如何解决上述问题完成垃圾收集过程的。... 2014-12-22 01:00 (27478) (15)
laoluo-112 | ART运行时垃圾收集机制简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/42072975 | description:为了学习ART运行时的垃圾收集机制，我们先把Dalvik虚拟机的垃圾收集机制研究了一遍。这是因为两者都使用到了Mark-Sweep算法，因此它们在概念上有很多一致的地方。然而在实现上，Dalvik虚拟机的垃圾收集机制要简单一些。这样我们就可以先从简单的Dalvik虚拟机垃圾收集机制入手，然后再逐步深入地学习复杂的ART运行时垃圾收集机制。本文就对ART运行时垃圾收集机制进行简要介绍和制定学习计划。... 2015-01-05 01:01 (14411) (23)
laoluo-113 | ART运行时Java堆创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/42379729 | parentid:laoluo-112 description:与Dalvik虚拟机一样，ART运行时内部也有一个Java堆，用来分配Java对象。当这些Java对象不再被使用时，ART运行时需要回收它们占用的内存。在前面一文中，我们简要介绍了ART运行时的垃圾收集机制，从中了解到ART运行时内部使用的Java堆是由四种Space以及各种辅助数据结构共同描述的。为了后面可以更好地分析ART运行时的垃圾收集机制，本文就对它内部使用的Java堆的创建过程进行分析。... 2015-01-12 00:59 (10216) (12)
laoluo-114 | ART运行时为新创建对象分配内存的过程分析 | http://blog.csdn.net/luoshengyang/article/details/42492621 | parentid:laoluo-112 description:ART运行时和Dalvik虚拟机一样，在堆上为对象分配内存时都要解决内存碎片和内存不足问题。内存碎片问题可以使用dlmalloc技术解决。内存不足问题则通过垃圾回收和在允许范围内增长堆大小解决。由于垃圾回收会影响程序，因此ART运行时采用力度从小到大的进垃圾回收策略。一旦力度小的垃圾回收执行过后能满足分配要求，那就不需要进行力度大的垃圾回收了。本文就详细分析ART运行时在堆上为对象分配内存的过程。... 2015-01-22 00:59 (8571) (7)
laoluo-115 | ART运行时垃圾收集（GC）过程分析 | http://blog.csdn.net/luoshengyang/article/details/42555483 | parentid:laoluo-112 description:ART运行时与Dalvik虚拟机一样，都使用了Mark-Sweep算法进行垃圾回收，因此它们的垃圾回收流程在总体上是一致的。但是ART运行时对堆的划分更加细致，因而在此基础上实现了更多样的回收策略。不同的策略有不同的回收力度，力度越大的回收策略，每次回收的内存就越多，并且它们都有各自的使用情景。这样就可以使得每次执行GC时，可以最大限度地减少应用程序停顿。本文就详细分析ART运行时的垃圾收集过程。... 2015-01-26 00:58 (23285) (14)
laoluo-116 | ART运行时Compacting GC简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/44513977 | description:在前面一个系列文章中，我们学习了Android 4.4 ART的Mark-Sweep（MS）GC。到了Android 5.0，ART增加了对Compacting GC的支持，包括Semi-Space（SS）、Generational Semi-Space（GSS）和Mark-Compact（MC）三种。本文对Android 5.0 ART的Compacting GC进行简要介绍以及制定学习计划。... 2015-03-23 00:59 (10627) (22)
laoluo-117 | ART运行时Compacting GC堆创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/44789295 | parentid:laoluo-116 description:引进了Compacting GC之后，ART运行时的堆空间结构就发生了变化。这是由于Compacting GC和Mark-Sweep GC的算法不同，要求底层的堆具有不同的空间结构。同时，即使是原来的Mark-Sweep GC，由于需要支持新的同构空间压缩特性（Homogeneous Space Compact），也使得它们要具有与原来不一样的堆空间结构。本文就对这些堆空间创建过程进行详细的分析。... 2015-04-07 01:00 (4936) (4)
laoluo-118 | ART运行时Compacting GC为新创建对象分配内存的过程分析 | http://blog.csdn.net/luoshengyang/article/details/44910271 | parentid:laoluo-116 description:在引进Compacting GC后，ART运行时优化了堆内存分配过程。最显著特点是为每个ART运行时线程增加局部分配缓冲区（Thead Local Allocation Buffer）和在OOM前进行一次同构空间压缩（Homogeneous Space Compact）。前者可提高堆内存分配效率，后者可解决内存碎片问题。本文就对ART运行时引进Compacting GC后的堆内存分配过程进行分析。... 2015-04-13 00:57 (18520) (7)
laoluo-119 | ART运行时Semi-Space（SS）和Generational Semi-Space（GSS）GC执行过程分析 | http://blog.csdn.net/luoshengyang/article/details/45017207 | parentid:laoluo-116 description:Semi-Space（SS）GC和Generational Semi-Space（GSS）GC是ART运行时引进的两个Compacting GC。它们的共同特点是都具有一个From Space和一个To Space。在GC执行期间，在From Space分配的还存活的对象会被依次拷贝到To Space中，这样就可以达到消除内存碎片的目的。本文就将SS GC和GSS GC的执行过程分析进行详细分析。... 2015-04-20 01:01 (4919) (12)
laoluo-120 | ART运行时Mark-Compact（ MC）GC执行过程分析 | http://blog.csdn.net/luoshengyang/article/details/45162589 | parentid:laoluo-116 description:除了Semi-Space（SS）GC和Generational Semi-Space（GSS）GC，ART运行时还引入了第三种Compacting GC：Mark-Compact（MC）GC。这三种GC虽然都是Compacting GC，不过它们的实现方式却有很大不同。SS GC和GSS GC需两个Space来压缩内存，而MC GC只需一个Space来压缩内存。本文就详细分析MC GC的执行过程。... 2015-04-27 01:00 (4625) (7)
laoluo-121 | ART运行时Foreground GC和Background GC切换过程分析 | http://blog.csdn.net/luoshengyang/article/details/45301715 | parentid:laoluo-116 description:通过前面一系列文章的学习，我们知道了ART运行时既支持Mark-Sweep GC，又支持Compacting GC。其中，Mark-Sweep GC执行效率更高，但是存在内存碎片问题；而Compacting GC执行效率较低，但是不存在内存碎片问题。ART运行时通过引入Foreground GC和Background GC的概念来对这两种GC进行扬长避短。本文就详细分析它们的执行过程以及切换过程。... 2015-05-04 00:57 (8928) (11)
laoluo-122 | Android应用程序UI硬件加速渲染技术简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/45601143 | description:Android系统的流畅性一直被拿来与iOS比较，并且认为不如后者。这一方面与Android设备硬件质量参差不齐有关，另一方面也与Android系统的实现有关。例如在3.0前，Android应用程序UI绘制不支持硬件加速。不过从4.0开始，Android系统一直以“run fast, smooth, and responsively”为目标对UI进行优化。本文对这些优化进行简要介绍和制定学习计划。... 2015-05-11 01:00 (17575) (16)
laoluo-123 | Android应用程序UI硬件加速渲染环境初始化过程分析 | http://blog.csdn.net/luoshengyang/article/details/45769759 | parentid:laoluo-122 description:在Android应用程序中，我们是通过Canvas API来绘制UI元素的。在硬件加速渲染环境中，这些Canvas API调用最终会转化为Open GL API调用（转化过程对应用程序来说是透明的）。由于Open GL API调用要求发生在Open GL环境中，因此在每当有新的Activity窗口启动时，系统都会为其初始化好Open GL环境。这篇文章就详细分析这个Open GL环境的初始化过程。... 2015-05-18 00:59 (12390) (13)
laoluo-124 | Android应用程序UI硬件加速渲染的预加载资源地图集服务（Asset Atlas Service）分析 | http://blog.csdn.net/luoshengyang/article/details/45831269 | parentid:laoluo-122 description:我们知道，Android系统在启动的时候，会对一些系统资源进行预加载。这样不仅使得应用程序在需要时可以快速地访问这些资源，还使得这些资源能够在不同应用程序之间进行共享。在硬件加速渲染环境中，这些预加载资源还有进一步优化的空间。Android系统提供了一个地图集服务，负责将预加载资源合成为一个纹理上传到GPU去，并且能够在所有的应用程序之间进行共享。本文就详细分析这个预加载资源地图集服务的实现原理。... 2015-05-25 00:58 (9946) (7)
laoluo-125 | Android应用程序UI硬件加速渲染的Display List构建过程分析 | http://blog.csdn.net/luoshengyang/article/details/45943255 | parentid:laoluo-122 description:在硬件加速渲染环境中，Android应用程序窗口的UI渲染是分两步进行的。第一步是构建Display List，发生在应用程序进程的Main Thread中；第二步是渲染Display List，发生在应用程序进程的Render Thread中。Display List是以视图为单位进行构建的，因此每一个视图都对应有一个Display List。本文详细分析这些Display List的构建过程。... 2015-06-01 01:00 (11917) (12)
laoluo-126 | Android应用程序UI硬件加速渲染的Display List渲染过程分析 | http://blog.csdn.net/luoshengyang/article/details/46281499 | parentid:laoluo-122 description:在硬件加速渲染环境中，Android应用程序窗口的UI渲染是分两步进行的。第一步是构建Display List，发生在应用程序进程的Main Thread中；第二步是渲染Display List，发生在应用程序进程的Render Thread中。Display List的渲染不是简单地执行绘制命令，而是包含了一系列优化操作，例如绘制命令的合并执行。本文就详细分析Display List的渲染过程。... 2015-06-15 01:01 (14910) (13)
laoluo-127 | Android应用程序UI硬件加速渲染的动画执行过程分析 | http://blog.csdn.net/luoshengyang/article/details/46449677 | parentid:laoluo-122 description:通常我们说一个系统不如另一个系统流畅，说的就是前者动画显示不如后者流畅，因此动画显示流畅程度是衡量一个系统流畅性的关键指标。为什么这样说呢？这是因为流畅的动画显示需要60fps的UI刷新速度，然而这却不是一个容易达到的速度。Android 5.0通过引入Render Thread尽最大努力提升动画显示流畅性。本文就分析Render Thread显示动画的过程，以便了解它是如何提高动画显示流畅性的。... 2015-06-23 01:00 (13416) (16)
laoluo-128 | Android Chromium WebView学习启动篇 | http://blog.csdn.net/luoshengyang/article/details/46569161 | parentid:laoluo-122 description:Android从4.4起提供基于Chromium实现的WebView。此前WebView基于WebKit实现。WebKit提供网页解析、布局和绘制以及JS运行等基础功能。Chromium在WebKit基础上为WebView提供进程、线程和渲染等基础构架。因此基于Chromium实现的WebView更好地提供了网页浏览功能。从本文开始我们启动对Android Chromium WebView的学习。... 2015-06-29 01:01 (22070) (37)
laoluo-129 | Chromium和WebKit的智能指针实现原理分析 | http://blog.csdn.net/luoshengyang/article/details/46598223 | parentid:laoluo-122 description:C++不像Java一样，由虚拟机负责对象分配和释放。也就是说，开发人员使用C++编写代码时，要自己负责对象分配和释放。WebKit和Chromium都是使用C++开发的，因此它们也面临上述问题。在解决对象释放问题时，要做到在对象不需要时自动释放，因为手动释放会带来忘记释放或者释放后又继续使用的隐患。智能指针是实现对象自动释放的有效技术手段。本文就分析Chromium和WebKit的智能指针的实现。... 2015-07-06 01:01 (11017) (15)
laoluo-130 | Chromium多线程通信的Closure机制分析 | http://blog.csdn.net/luoshengyang/article/details/46747797 | parentid:laoluo-122 description:为了充分利用CPU多核特性，Chromium在启动时会创建很多线程，来负责执行不同的操作。这样就涉及到了多线程通信问题。Chromium为每一个线程都创建了一个消息队列。当一个线程需要另一个线程执行某一操作时，就向该线程的消息队列发送一个Callback。这个Callback最终在目标线程中得到执行。这种基于Callback的多线程通信方式在Chromium中很普通，因此本文就对它的实现进行分析。... 2015-07-13 01:01 (11278) (6)
laoluo-131 | Chromium多线程模型设计和实现分析 | http://blog.csdn.net/luoshengyang/article/details/46855395 | parentid:laoluo-122 description:Chromium除了远近闻名的多进程架构之外，它的多线程模型也相当引人注目的。Chromium的多进程架构是为了解决网页的稳定性问题，而多线程模型则是为了解决网页的卡顿问题。为了达到这个目的，Chromium的多线程模型是基于异步通信的。也就是说，一个线程请求另外一个线程执行一个任务的时候，不需要等待该任务完成就可以去做其它事情，从而避免了卡顿。本文就分析Chromium的多线程模型的设计和实现。... 2015-07-27 00:59 (12092) (17)
laoluo-132 | Chromium多进程架构简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/47364477 | description:Chromium以多进程架构著称，它主要包含四类进程，分别是Browser进程、Render进程、GPU进程和Plugin进程。之所以要将Render进程、GPU进程和Plugin进程独立出来，是为了解决它们的不稳定性问题。也就是说，Render进程、GPU进程和Plugin进程由于不稳定而引发的Crash不会导致整个浏览器崩溃。本文就对Chromium的多进程架构进行简要介绍，以及制定学习计划。... 2015-08-10 01:04 (11385) (12)
laoluo-133 | Chromium的Render进程启动过程分析 | http://blog.csdn.net/luoshengyang/article/details/47433765 | parentid:laoluo-132 description:在配置多进程的情况下，Chromium的网页渲染和JS执行在一个单独的进程中进行。这个进程称为Render进程，由Browser进程启动。在Android平台中，Browser进程就是Android应用程序的主进程，而Render进程就是Android应用程序的Service进程，它们通过UNIX Socket进行通信。本文就详细分析Chromium的Browser进程启动Render进程的过程。... 2015-08-24 01:06 (9626) (9)
laoluo-134 | Chromium的IPC消息发送、接收和分发机制分析 | http://blog.csdn.net/luoshengyang/article/details/47822689 | parentid:laoluo-132 description:由于Chromium采用多进程架构，因此会涉及到进程间通信问题。通过前面一文的学习，我们知道Browser进程在启动Render进程的过程中会建立一个以UNIX Socket为基础的IPC通道。有了IPC通道之后，接下来Browser进程与Render进程就以消息的形式进行通信。我们将这种消息称为IPC消息，以区别于线程消息循环中的消息。本文就分析Chromium的IPC消息发送、接收和分发机制。... 2015-08-31 01:01 (10657) (9)
laoluo-135 | Chromium的GPU进程启动过程分析 | http://blog.csdn.net/luoshengyang/article/details/48123761 | parentid:laoluo-132 description:Chromium除了有Browser进程和Render进程，还有GPU进程。GPU进程负责Chromium的GPU操作，例如Render进程通过GPU进程离屏渲染网页，Browser进程也是通过GPU进程将离屏渲染好的网页显示在屏幕上。Chromium之所以将GPU操作运行在独立进程中，是考虑到稳定性问题。毕竟GPU操作是硬件相关操作，硬件的差异性会引发一定的不稳性。本文分析GPU进程的启动过程。... 2015-09-14 01:01 (10040) (8)
laoluo-136 | Chromium的Plugin进程启动过程分析 | http://blog.csdn.net/luoshengyang/article/details/48417255 | parentid:laoluo-132 description:前面我们分析了Chromium的Render进程和GPU进程的启动过程，它们都是由Browser进程启动的。在Chromium中，还有一类进程是由Browser进程启动的，它们就是Plugin进程。顾名思义，Plugin进程是用来运行浏览器插件的。浏览器插件的作用是扩展网页功能，它们由第三方开发，安全性和稳定性都无法得到保证，因此运行在独立的进程中。本文接下来就详细分析Plugin进程的启动过程。... 2015-09-21 01:00 (8204) (3)
laoluo-137 | Chromium硬件加速渲染机制基础知识简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/48820095 | description:Chromium支持硬件加速渲染网页，即使用GPU渲染网页。在多进程架构下，Browser、Render和Plugin进程的GPU命令不是在本进程中执行的，而是转发给GPU进程执行。这是因为GPU命令是硬件相关操作，不同平台的实现不一样，从而导致不稳定，而将不稳定操作放在独立进程中执行可以保护主进程的稳定性。本文对Chromium硬件加速渲染机制的基础知识进行简要介绍和制定学习计划。... 2015-10-12 01:01 (7932) (9)
laoluo-138 | Chromium硬件加速渲染的OpenGL上下文绘图表面创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/48947685 | parentid:laoluo-137 description:GPU命令需要在OpenGL上下文中执行。每一个OpenGL上下文都关联有一个绘图表面，GPU命令就是作用在绘图表面上的。不同用途的OpenGL上下文关联的绘图表面不一样，例如用于离屏渲染的OpenGL上下文关联的绘图表面可以用Pbuffer描述，而用于屏幕渲染的OpenGL上下文的绘图表面要用本地窗口描述。本文分析Chromium硬件加速渲染涉及到的OpenGL上下文及其联的绘图表面的关联过程。... 2015-10-19 01:00 (7430) (4)
laoluo-139 | Chromium硬件加速渲染的OpenGL上下文创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/49305479 | parentid:laoluo-137 description:在Chromium中，WebGL端、Render端和Browser端的GPU命令都是通过GPU进程中的一个GPU线程来执行的。这三端的GPU命令是独立执行的，不能相互发生影响。为了达到这个目的，GPU线程分别为它们创建不同的OpenGL上下文，并且使得它们的GPU命令在各自的OpenGL上下文中执行。本文接下来就详细分析WebGL端、Render端和Browser端的OpenGL上下文的创建过程。... 2015-11-02 01:00 (6643) (5)
laoluo-140 | Chromium硬件加速渲染的OpenGL命令执行过程分析 | http://blog.csdn.net/luoshengyang/article/details/49531403 | parentid:laoluo-137 description:在Chromium中，由于GPU进程的存在，WebGL端、Render端和Browser端的GPU命令是代理给GPU进程执行的。Chromium将它们要执行的GPU命令进行编码，然后写入到一个命令缓冲区中，最后传递给GPU进程。GPU进程从这个命令缓冲区读出GPU命令之后，就进行解码，然后调用对应的OpenGL函数。本文就详细分析WebGL端、Render端和Browser端执行GPU命令的过程。。... 2015-11-09 01:00 (8720) (5)
laoluo-141 | Chromium硬件加速渲染的GPU数据上传机制分析 | http://blog.csdn.net/luoshengyang/article/details/49750961 | parentid:laoluo-137 description:在Chromium中，WebGL端、Render端和Browser端通过命令缓冲区将GPU命令发送给GPU进程执行。GPU命令携带的简单参数也通过命令缓冲区发送给GPU进程，但复杂参数，例如纹理数据，有可能太大，以致于命令缓冲区无法容纳，因此要通过其它机制传递给GPU进程。本文接下来就主要以纹理数据上传为例，分析WebGL端、Render端和Browser端将GPU命令数据传递给GPU进程的机制。... 2015-11-23 01:01 (8681) (15)
laoluo-142 | Chromium硬件加速渲染的OpenGL上下文调度过程分析 | http://blog.csdn.net/luoshengyang/article/details/50005571 | parentid:laoluo-137 description:Chromium的每一个WebGL端、Render端和Browser端实例在GPU进程中都有一个OpenGL上下文。这些OpenGL上下文运行在相同线程中，因此同一时刻只有一个OpenGL上下文处于运行状态。这就引发出一个OpenGL上下文调度问题。此外，事情有轻重缓急，OpenGL上下文也有优先级高低之分，优先级高的要保证它的运行时间。本文接下来就分析GPU进程调度运行OpenGL上下文的过程。... 2015-12-07 01:02 (7621) (19)
laoluo-143 | Chromium硬件加速渲染的UI合成过程分析 | http://blog.csdn.net/luoshengyang/article/details/50226555 | parentid:laoluo-137 description:在Chromium中，Render端和WebGL端绘制出来的UI最终是通过Browser端显示在屏幕上的。换句话说，就是Browser端负责合成Render端和WebGL端的UI。这涉及到不同OpenGL上下文之间的资源传递和同步问题。其中，资源传递问题通过Mailbox机制解决，同步问题通过Sync Point机制解决。本文接下来就分析Browser端合成Render端和WebGL端UI的过程。... 2015-12-21 00:58 (8261) (17)
laoluo-144 | Chromium网页加载过程简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/50414848 | description:Chromium加载网页的过程，需要Browser进程和Render进程协作完成。加载网页的过程由Browser进程发起，向服务器请求网页内容的过程也是由Browser进程完成。Render进程负责对下载回来的网页内容进行解析，解析之后得到一个DOM Tree。有了这个DOM Tree之后，Render进程就可以对网页进行渲染了。本文接下来就对上述过程涉及到的重要概念进行简要介绍以及制定学习计划。... 2016-01-04 00:59 (7483) (4)
laoluo-145 | Chromium网页Frame Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50450100 | parentid:laoluo-144 description:Chromium在加载一个网页之前，需要在Browser进程创建一个Frame Tree。Browser进程为网页创建了Frame Tree之后，再请求Render进程加载其内容。Frame Tree将网页抽象为Render Frame。Render Frame是为实现Out-of-Process iframes设计的。本文接下来就分析Frame Tree的创建过程，为后面分析网页加载过程打基础。... 2016-01-11 00:59 (7158) (18)
laoluo-146 | Chromium网页URL加载过程分析 | http://blog.csdn.net/luoshengyang/article/details/50527574 | parentid:laoluo-144 description:Chromium在Browser进程中为网页创建了一个Frame Tree之后，会将网页的URL发送给Render进程进行加载。Render进程接收到网页URL加载请求之后，会做一些必要的初始化工作，然后请求Browser进程下载网页的内容。Browser进程一边下载网页内容，一边又通过共享内存将网页内容传递给Render进程解析，也就是创建DOM Tree。本文接下来就分析网页URL的加载过程。... 2016-01-25 01:00 (14763) (5)
laoluo-147 | Chromium网页DOM Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50558942 | parentid:laoluo-144 description:在Chromium中，Render进程是通过Browser进程下载网页内容的，后者又是通过共享内存将下载回来的网页内容交给前者的。Render进程获得网页内容之后，会交给WebKit进行处理。WebKit所做的第一个处理就是对网页内容进行解析，解析的结果是得到一棵DOM Tree。DOM Tree是网页的一种结构化描述，也是网页渲染的基础。本文接下来就对网页DOM Tree的创建过程进行详细分析。... 2016-02-01 01:01 (5676) (8)
laoluo-148 | Chromium网页Render Object Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50615628 | parentid:laoluo-144 description:在前面一文中，我们分析了网页DOM Tree的创建过程。网页DOM Tree创建完成之后，WebKit会根据它的内容创建一个Render Object Tree。Render Object Tree是和网页渲染有关的一个Tree。这意味着只有在DOM Tree中需要渲染的节点才会在Render Object Tree中有对应节点。本文接下来就分析网页Render Object Tree的创建过程。... 2016-02-15 00:59 (4810) (1)
laoluo-149 | Chromium网页Render Layer Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50648792 | parentid:laoluo-144 description:在前面一文中，我们分析了网页Render Object Tree的创建过程。在创建Render Object Tree的同时，WebKit还会创建Render Layer Tree，但不是每一个Render Object都有对应的Render Layer。Render Layer是一个最小渲染单元，被若干Render Object共用。本文接下来就分析Render Layer Tree的创建过程。... 2016-02-22 00:59 (4281) (4)
laoluo-150 | Chromium网页Graphics Layer Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50661553 | parentid:laoluo-144 description:在前面一文中，我们分析了网页Render Layer Tree的创建过程。在创建Render Layer的同时，WebKit还会为其创建Graphics Layer。这些Graphics Layer形成一个Graphics Layer Tree。Graphics Layer可看作是一个图形缓冲区，被若干Render Layer共用。本文接下来就分析Graphics Layer Tree的创建过程。... 2016-02-29 00:59 (4649) (7)
laoluo-151 | Chromium网页渲染机制简要介绍和学习计划 | http://blog.csdn.net/luoshengyang/article/details/50916769 | description:作为一个浏览器，快速地将网页渲染出来是最重要的工作。Chromium为了做到这一点，费尽了心机，做了大量优化工作。这些优化工作是卓有成效的，代表了当今最先进的网页渲染技术。值得一提的是，这些渲染技术不仅适用于网页渲染，也可以应用在原生系统的UI渲染上。例如，在Android系统上，我们就可以看到两者在渲染技术上的相似之处。本文接下来就对Chromium的网页渲染机制进行简要介绍，并且制定学习计划。... 2016-03-21 01:00 (4420) (4)
laoluo-152 | Chromium网页Layer Tree创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50941980 | parentid:laoluo-151 description:在Chromium中，WebKit会创建一个Graphics Layer Tree描述网页。Graphics Layer Tree是和网页渲染相关的一个Tree。网页渲染最终由Chromium的CC模块完成，因此CC模块又会根据Graphics Layer Tree创建一个Layer Tree，以后就会根据这个Layer Tree对网页进行渲染。本文接下来就分析网页Layer Tree的创建过程。... 2016-03-28 01:02 (4464) (8)
laoluo-153 | Chromium网页渲染调度器（Scheduler）实现分析 | http://blog.csdn.net/luoshengyang/article/details/51054990 | parentid:laoluo-151 description:在采用线程化渲染方式渲染网页时，Chromium依赖一个调度器协调Main线程和Compositor线程的执行，同时也通过这个调度器决定它们什么时候该执行什么操作。调度器将Main线程和Compositor线程的当前状态记录在一个状态机中，然后通过这个状态机决定下一个要执行的操作。这个操作在满足当前设置条件下是最优的，因此可以使网页渲染更快更流畅。本文接下来就分析Chromium网页调度器的实现。... 2016-04-11 00:59 (3635) (3)
laoluo-154 | Chromium网页绘图表面（Output Surface）创建过程分析 | http://blog.csdn.net/luoshengyang/article/details/50995124 | parentid:laoluo-151 description:在Chromium中，Render进程在绘制网页之前，要为网页创建一个绘图表面。绘图表面描述的是网页经过渲染之后得到的输出。这个输出需要交给Browser进程处理，才能显示在屏幕上。在硬件加速渲染条件下，这个输出有可能是一个OpenGL纹理，也有可能是一系列需要进一步进行绘制的OpenGL纹理，取决于Render进程使用直接渲染器还是委托渲染器。本文接下来就对网页的绘图表面的创建过程进行详细分析。... 2016-04-18 01:00 (6888) (4)
laoluo-155 | Chromium网页Layer Tree绘制过程分析 | http://blog.csdn.net/luoshengyang/article/details/51148299 | parentid:laoluo-151 description:网页绘图表面创建完成之后，调度器就会请求绘制CC Layer Tree，这样网页在加载完成之后就能快速显示出来。通过CC Layer Tree可以依次找到Graphics Layer Tree、Render Layer Tree和Render Object Tree。有了Render Object Tree之后，就可以执行具体的绘制工作了。接下来我们就分析网页CC Layer Tree的绘制过程。... 2016-04-25 00:59 (8322) (15)
laoluo-156 | Chromium网页Layer Tree同步为Pending Layer Tree的过程分析 | http://blog.csdn.net/luoshengyang/article/details/51216442 | parentid:laoluo-151 description:CC Layer Tree绘制完成后，会同步到一个新的CC Pending Layer Tree去。同步过程由Compositor线程执行，并且Main线程处于等待状态。所谓同步，就是将CC Layer Tree的内容拷贝到CC Pending Layer Tree去。同步完毕，Main线程就会被唤醒。本文接下来分析CC Layer Tree同步为CC Pending Layer Tree的过程。... 2016-05-09 01:02 (4565) (10)
